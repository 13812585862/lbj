（1）ES5/ES6 的继承除了写法以外还有什么区别？
1.class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
2.class 声明内部会启用严格模式。(引用一个未声明的变量报错)
3.class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
4.class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
5.必须使用 new 调用 class。
6.class 内部无法重写类名。

（2）setTimeout、Promise、Async/Await 的区别
考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。
其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，
遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

（3）Async/Await 如何通过同步的方式实现异步
一个函数如果加上 async ，那么该函数就会返回一个 Promise。
await 只能在 async 函数中使用，可以把 async 看成将函数返回值使用 Promise.resolve() 包裹了下。
async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，
因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。
Async/Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式

（4）new运算符都做了哪些操作呢？
1、创建了一个新对象（是Object类型的数据）
2、将this指向新对象
3、将创建的对象的原型指向构造函数的原型
4、返回一个对象（如果构造函数本身有返回值且是对象类型，就返回本身的返回值，如果没有才返回新对象）

下面就写一个实现new功能的函数：

function mynew () {
     // 1、创建一个新对象
     const obj = Object.create({});    // 也可以写成 const obj = {}
     // 2、将this指向该对象
     let Fn = [].shift.call(arguments);    // 把构造函数分离出来
     let returnObj = Fn.apply(obj, arguments);     // 通过apply将this指向由Fn变为obj
     
     // 3、将新对象的原型指向构造函数的原型
     obj.__proto__ = Fn.prototype
     
    // 4、返回对象（如果构造函数有返回对象，那么就返回构造函数的对象，如果没有就返回新对象）
    return Object.prototype.toString.call(returnObj) == '[object Object]' ? returnObj : obj;
}


function _new2(fn, ...arg) {
   // 这一句话只是构造了一个对象，这个对象的__proto__=== fn.prototype
   var obj = Object.create(fn.prototype)
   // 并没有给这个对象赋值，将fn的this对象设置为obj
   // call 是列表， apply是数组
   const ret = fn.call(obj, ...arg) 
   // 为啥这里需要判断一下ret，根据new的定义，如果构造函数没有返回一个对象，那么返回this对象，this当前就是obj
   return ret instanceof Object ? ret : obj 
};function Person(age){this.age=age;};var s=_new2(Person,10);console.log(s);

（5）简单讲解一下 http2 的多路复用
HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。
多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。
HTTP2中

同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
单个连接上可以并行交错的请求和响应，之间互不干扰
