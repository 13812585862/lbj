（1）ES5/ES6 的继承除了写法以外还有什么区别？
1.class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
2.class 声明内部会启用严格模式。(引用一个未声明的变量报错)
3.class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
4.class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
5.必须使用 new 调用 class。
6.class 内部无法重写类名。

（2）setTimeout、Promise、Async/Await 的区别
考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。
其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，
遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

（3）Async/Await 如何通过同步的方式实现异步
一个函数如果加上 async ，那么该函数就会返回一个 Promise。
await 只能在 async 函数中使用，可以把 async 看成将函数返回值使用 Promise.resolve() 包裹了下。
async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，
因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。
Async/Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式
